/**
 * @file Firestore Security Rules for BeMatch
 * @version Prototyping
 *
 * @description
 * This ruleset enforces a strict user-ownership model for profile data and a collaborative model for matches and chat messages.
 *
 * @dataStructure
 * - User profiles are stored under `/users/{userId}/profile`.
 * - Matches are stored under `/matches/{matchId}` and denormalized under `/users/{userId}/matches/{matchId}` for efficient querying.
 * - Chat messages are stored under `/matches/{matchId}/messages/{messageId}`.
 *
 * @keySecurityDecisions
 * - User listing is disallowed.
 * - Data shape validation is minimized for rapid prototyping. Only authorization-critical fields are validated.
 *
 * @denormalizationForAuthorization
 * - Match data includes `user1Id` and `user2Id` to ensure that each user can independently authorize access to their matches.  This is duplicated in both `/matches/{matchId}` and `/users/{userId}/matches/{matchId}`.
 *
 * @structuralSegregation
 * - User-specific data is stored under `/users/{userId}`.
 * - Match-specific data is stored under `/matches/{matchId}`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile data. Only the user (or an admin) can read or write their own profile.
     * @path /users/{userId}/profile
     * @allow (get, update, delete) if isSignedIn() && isOwner(userId); User can read, update, or delete their own profile.
     * @allow (create) if isSignedIn() && request.auth.uid == userId; User can create their own profile.
     * @deny (get, list) if !isSignedIn(); Anonymous user cannot access user profiles.
     * @deny (create, update, delete) if !isSignedIn(); Anonymous user cannot modify user profiles.
     * @deny (create) if isSignedIn() && request.auth.uid != userId; User cannot create a profile for another user.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/profile {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to match data.  Allows read access to all but restricts writes to only authorized users.
     * @path /matches/{matchId}
     * @allow (get, list) if true;  Anyone can read matches.
     * @allow (create) if request.resource.data.user1Id == request.auth.uid || request.resource.data.user2Id == request.auth.uid; A user in the match can create it.
     * @allow (update, delete) if (isSignedIn() && (resource.data.user1Id == request.auth.uid || resource.data.user2Id == request.auth.uid)); Only users in a match can update or delete it.
     * @deny (create, update, delete) if !isSignedIn(); Anonymous user cannot modify matches.
     * @principle Restricts writes to users who are part of the match.
     */
    match /matches/{matchId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn() && (request.resource.data.user1Id == request.auth.uid || request.resource.data.user2Id == request.auth.uid);
      allow update: if isSignedIn() && (resource.data.user1Id == request.auth.uid || resource.data.user2Id == request.auth.uid);
      allow delete: if isSignedIn() && (resource.data.user1Id == request.auth.uid || resource.data.user2Id == request.auth.uid);
    }

    /**
     * @description Controls access to denormalized match data for a specific user. Ensures authorization independence.
     * @path /users/{userId}/matches/{matchId}
     * @allow (get, list) if isSignedIn() && isOwner(userId); User can read their own match data.
     * @allow (create) if isSignedIn() && isOwner(userId) && (request.resource.data.user1Id == userId || request.resource.data.user2Id == userId); User can create match data for themselves if they are one of the matched users.
     * @allow (update, delete) if isSignedIn() && isOwner(userId) && (resource.data.user1Id == userId || resource.data.user2Id == userId); User can update/delete their match data if they are one of the matched users.
     * @deny (get, list, create, update, delete) if !isSignedIn(); Anonymous users cannot access match data.
     * @deny (create) if isSignedIn() && !isOwner(userId); User cannot create match data under another user's ID.
     * @principle Enforces user-specific access to denormalized match data.
     */
    match /users/{userId}/matches/{matchId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && (request.resource.data.user1Id == userId || request.resource.data.user2Id == userId);
      allow update: if isSignedIn() && isOwner(userId) && (resource.data.user1Id == userId || resource.data.user2Id == userId);
      allow delete: if isSignedIn() && isOwner(userId) && (resource.data.user1Id == userId || resource.data.user2Id == userId);
    }

    /**
     * @description Controls access to chat messages within a match.  Only users who are part of the match can read or write messages.
     * @path /matches/{matchId}/messages/{messageId}
     * @allow (get, list) if isSignedIn() && (get(/databases/$(database)/documents/matches/$(matchId)).data.user1Id == request.auth.uid || get(/databases/$(database)/documents/matches/$(matchId)).data.user2Id == request.auth.uid); Only users in a match can read messages.
     * @allow (create) if isSignedIn() && (get(/databases/$(database)/documents/matches/$(matchId)).data.user1Id == request.auth.uid || get(/databases/$(database)/documents/matches/$(matchId)).data.user2Id == request.auth.uid); Only users in a match can create messages.
     * @allow (update, delete) if isSignedIn() && (get(/databases/$(database)/documents/matches/$(matchId)).data.user1Id == request.auth.uid || get(/databases/$(database)/documents/matches/$(matchId)).data.user2Id == request.auth.uid); Only users in a match can update or delete messages.
     * @deny (get, list, create, update, delete) if !isSignedIn(); Anonymous user cannot access chat messages.
     * @principle Restricts access to chat messages to users who are participants in the match.
     */
    match /matches/{matchId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn() && (get(/databases/$(database)/documents/matches/$(matchId)).data.user1Id == request.auth.uid || get(/databases/$(database)/documents/matches/$(matchId)).data.user2Id == request.auth.uid);
      allow create: if isSignedIn() && (get(/databases/$(database)/documents/matches/$(matchId)).data.user1Id == request.auth.uid || get(/databases/$(database)/documents/matches/$(matchId)).data.user2Id == request.auth.uid);
      allow update: if isSignedIn() && (get(/databases/$(database)/documents/matches/$(matchId)).data.user1Id == request.auth.uid || get(/databases/$(database)/documents/matches/$(matchId)).data.user2Id == request.auth.uid);
      allow delete: if isSignedIn() && (get(/databases/$(database)/documents/matches/$(matchId)).data.user1Id == request.auth.uid || get(/databases/$(database)/documents/matches/$(matchId)).data.user2Id == request.auth.uid);
    }
  }
}