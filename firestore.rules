/**
 * @file Firestore Security Rules for BeMatch App
 * @core_philosophy This ruleset enforces a strict user-ownership model for user profiles and a closed-collaborator model for matches and messages, using denormalization to ensure authorization independence.
 * @data_structure
 *   - /users/{userId}: Stores user profiles; document ID is the Firebase Auth UID.
 *   - /matches/{matchId}: Stores matches between users, with denormalized user1Id and user2Id fields for authorization.
 *   - /matches/{matchId}/messages/{messageId}: Stores messages within a match, with denormalized user1Id and user2Id fields from the parent 'match' document.
 * @key_security_decisions
 *   - User profiles are strictly private and only accessible to the owning user.
 *   - Matches are only accessible to the two users involved.
 *   - Messages are only accessible to the two users involved in the parent match.
 *   - User listing is disallowed for the /users collection.
 * @denormalization_for_authorization The 'matches' collection denormalizes user IDs, and the 'messages' collection denormalizes user IDs from the parent 'match' document. This ensures that access control can be enforced based on the contents of each document, without needing to perform expensive and brittle `get()` operations to fetch parent data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages access to user profiles. Only the owner can read and write their own profile.
     * @path /users/{userId}
     * @allow (create) User with UID 'user_abc' can create a profile at /users/user_abc.
     * @allow (get, update, delete) User with UID 'user_abc' can read/update/delete their profile at /users/user_abc.
     * @deny (create) User with UID 'user_xyz' cannot create a profile at /users/user_abc.
     * @deny (get, update, delete) User with UID 'user_xyz' cannot read/update/delete the profile at /users/user_abc.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // Listing all users is not permitted.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id; // Enforce immutability of userId
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages access to matches between users. Only the users involved in the match can read and write the match data.
     * @path /matches/{matchId}
     * @allow (create) User with UID 'user_abc' can create a match where they are either user1 or user2.
     * @allow (get, update, delete) User with UID 'user_abc' can read/update/delete a match where they are either user1 or user2.
     * @deny (get, update, delete) User with UID 'user_xyz' cannot read/update/delete a match where they are not user1 or user2.
     * @principle Enforces shared access based on user IDs within the document.
     */
    match /matches/{matchId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant(user1Id, user2Id) {
        return request.auth.uid == user1Id || request.auth.uid == user2Id;
      }

      function isExistingParticipant(user1Id, user2Id) {
          return isParticipant(user1Id, user2Id) && resource != null;
      }
      allow get: if isSignedIn() && isParticipant(resource.data.user1Id, resource.data.user2Id);
      allow list: if isSignedIn() && (request.query.field == 'user1Id' && request.query.value == request.auth.uid || request.query.field == 'user2Id' && request.query.value == request.auth.uid);
      allow create: if isSignedIn() && isParticipant(request.resource.data.user1Id, request.resource.data.user2Id) && (request.resource.data.user1Id == request.auth.uid || request.resource.data.user2Id == request.auth.uid);
      allow update: if isExistingParticipant(resource.data.user1Id, resource.data.user2Id);
      allow delete: if isExistingParticipant(resource.data.user1Id, resource.data.user2Id);
    }

    /**
     * @description Manages access to messages within a match. Only the users involved in the parent match can read and write messages.
     * @path /matches/{matchId}/messages/{messageId}
     * @allow (create) User with UID 'user_abc' can create a message within a match they are participating in.
     * @allow (get, update, delete) User with UID 'user_abc' can read/update/delete a message within a match they are participating in.
     * @deny (get, update, delete) User with UID 'user_xyz' cannot read/update/delete a message within a match they are not participating in.
     * @principle Enforces shared access to subcollection based on parent document data.
     */
    match /matches/{matchId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant(matchId) {
        return get(/databases/$(database)/documents/matches/$(matchId)).data.user1Id == request.auth.uid
            || get(/databases/$(database)/documents/matches/$(matchId)).data.user2Id == request.auth.uid;
      }

      function isExistingParticipant(matchId) {
        return isParticipant(matchId) && resource != null;
      }
      allow get: if isSignedIn() && isParticipant(matchId);
      allow list: if isSignedIn() && isParticipant(matchId);
      allow create: if isSignedIn() && isParticipant(matchId) && (request.resource.data.senderId == request.auth.uid);
      allow update: if isExistingParticipant(matchId) && (request.resource.data.senderId == resource.data.senderId);
      allow delete: if isExistingParticipant(matchId);
    }
  }
}