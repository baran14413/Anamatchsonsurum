{
  "entities": {
    "UserProfile": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserProfile",
      "type": "object",
      "description": "Represents a user's profile on the BeMatch app.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the UserProfile entity."
        },
        "fullName": {
          "type": "string",
          "description": "The user's full name."
        },
        "dateOfBirth": {
          "type": "string",
          "description": "The user's date of birth.",
          "format": "date-time"
        },
        "gender": {
          "type": "string",
          "description": "The user's gender."
        },
        "profilePictures": {
          "type": "array",
          "description": "Array of URLs to the user's profile pictures.",
          "items": {
            "type": "string"
          }
        },
        "interests": {
          "type": "array",
          "description": "Array of user's interests.",
          "items": {
            "type": "string"
          }
        },
        "bio": {
          "type": "string",
          "description": "A short biography or description of the user."
        },
        "location": {
          "type": "string",
          "description": "The user's location."
        }
      },
      "required": [
        "id",
        "fullName",
        "dateOfBirth",
        "gender",
        "profilePictures",
        "interests",
        "bio",
        "location"
      ]
    },
    "Match": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Match",
      "type": "object",
      "description": "Represents a match between two users.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Match entity."
        },
        "user1Id": {
          "type": "string",
          "description": "Reference to UserProfile. (Relationship: UserProfile 1:N Match) The ID of the first user in the match."
        },
        "user2Id": {
          "type": "string",
          "description": "Reference to UserProfile. (Relationship: UserProfile 1:N Match) The ID of the second user in the match."
        },
        "matchDate": {
          "type": "string",
          "description": "The date when the match occurred.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "user1Id",
        "user2Id",
        "matchDate"
      ]
    },
    "Message": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Message",
      "type": "object",
      "description": "Represents a message exchanged between users.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Message entity."
        },
        "senderId": {
          "type": "string",
          "description": "Reference to UserProfile. (Relationship: UserProfile 1:N Message) The ID of the user who sent the message."
        },
        "receiverId": {
          "type": "string",
          "description": "Reference to UserProfile. (Relationship: UserProfile 1:N Message) The ID of the user who received the message."
        },
        "matchId": {
          "type": "string",
          "description": "Reference to Match. (Relationship: Match 1:N Message) The ID of the match this message belongs to."
        },
        "messageText": {
          "type": "string",
          "description": "The content of the message."
        },
        "timestamp": {
          "type": "string",
          "description": "The timestamp of when the message was sent.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "senderId",
        "receiverId",
        "matchId",
        "messageText",
        "timestamp"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "UserProfile",
          "schema": {
            "$ref": "#/backend/entities/UserProfile"
          },
          "description": "Stores user profiles. Document ID is the Firebase Auth UID. Path-based ownership enables secure access. Denormalized 'userId' field from auth token.",
          "params": [
            {
              "name": "userId",
              "description": "The Firebase Auth UID of the user."
            }
          ]
        }
      },
      {
        "path": "/matches/{matchId}",
        "definition": {
          "entityName": "Match",
          "schema": {
            "$ref": "#/backend/entities/Match"
          },
          "description": "Stores matches between users. Includes denormalized 'user1Id' and 'user2Id' fields for authorization independence.",
          "params": [
            {
              "name": "matchId",
              "description": "Unique ID of the match document."
            }
          ]
        }
      },
      {
        "path": "/matches/{matchId}/messages/{messageId}",
        "definition": {
          "entityName": "Message",
          "schema": {
            "$ref": "#/backend/entities/Message"
          },
          "description": "Stores messages within a match. Includes denormalized 'user1Id' and 'user2Id' from the parent 'match' document for authorization independence.",
          "params": [
            {
              "name": "matchId",
              "description": "The ID of the match the message belongs to."
            },
            {
              "name": "messageId",
              "description": "The unique ID of the message."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to support the core features of the BeMatch app, focusing on user profiles, matches, and real-time messaging. The structure prioritizes authorization independence, clarity, and scalability.\n\n*   **UserProfile:** User profiles are stored in a `users` collection using the user's UID as the document ID. This enables path-based ownership, simplifying security rules. All profile data is stored directly within the user document.\n*   **Matches:** Matches between users are stored in a `matches` collection. Each match document contains references to the two users involved (`user1Id`, `user2Id`). To achieve authorization independence and enable secure listing of matches for a given user, the `matches` collection will denormalize the `user1Id` and `user2Id` fields. Security rules will leverage these fields to control access.\n*   **Messages:** Messages are stored in a subcollection `messages` under each `match` document. This hierarchical structure ensures that messages are directly associated with their corresponding match. Each message includes `senderId`, `receiverId`, and `matchId` for easy querying. Similar to matches, to support authorization independence, each `message` will include a denormalized `user1Id` and `user2Id` from the parent `match` document.\n\n**Authorization Independence:**\nAuthorization independence is achieved primarily through denormalization. The `matches` collection denormalizes user IDs, and the `messages` collection denormalizes the user IDs from the parent `match` document. This ensures that access control can be enforced based on the contents of each document, without needing to perform expensive and brittle `get()` operations to fetch parent data.\n\n**QAPs (Rules are not Filters):**\nThe structure supports secure `list` operations via structural segregation and path-based ownership. For `users`, the `list` operation is restricted to authenticated users viewing their profile data. For `matches`, a user can only list matches where their user ID is present as either `user1Id` or `user2Id` (denormalized fields). For `messages`, a user can only list messages under a specific match, and the match document itself enforces that the user is one of the participants. This prevents users from listing all messages across the entire database. Global roles are not required, as access is controlled via path-based ownership and membership denormalization."
  }
}